clear all
close all
clc
addpath Functions

%% 

% Function defines important variables, inspect the function
% defineConstants for the definition of all variables
[phi, g, m, J_t,d, S, l,Sm,C_A, C_Y_beta,C_N_alpha, C_m_q, C_m_alpha, C_n_r, C_n_beta,rho] = defineConstants;

variables = [phi, g, m, J_t,d, S, l,Sm,C_A, C_Y_beta,C_N_alpha, C_m_q, C_m_alpha, C_n_r, C_n_beta];

% Initialize the symbolic dynamics, such that we can take the Jacobian
% later
symbolicDynamics = initSymbolicSysDynamics(phi, g, m, J_t,d, S, l,Sm,C_A, C_Y_beta,C_N_alpha, C_m_q, C_m_alpha, C_n_r, C_n_beta,rho);

syms theta Psi v w u p q r mu1 mu2 T


symbolicDisturbances = [];
symbolicStates = [theta Psi v w u p q r];
symbolicInputs = [mu1 mu2 T];

stateOperatingPoints = [0 1 2 3 4 5 6 7];

inputOperatingPoints = [3 4 5];

disturbanceOperatingPoints = [];


LTI = linearizeDynamics(symbolicDynamics,symbolicStates,symbolicInputs,symbolicDisturbances,stateOperatingPoints,inputOperatingPoints,disturbanceOperatingPoints);